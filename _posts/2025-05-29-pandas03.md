---
title: "Pandas 실습 Part 4"
date: 2025-05-28
author: "정우민"
layout: post
categories : pandas
tags: [pandas, python, data-transformation, melt]
summary: "Pandas의 melt 함수를 활용해 넓은 데이터를 긴 형태로 바꾸는 방법을 실습 예제와 함께 설명합니다."
---

# melt 함수로 데이터 재구조화

이번 포스트에서는 Pandas의 **`melt()` 함수**를 이용해 **데이터의 형태를 변형하는 방법**에 대해 알아봅니다. 특히, **Wide format → Long format**으로의 변환에 자주 활용되며, 시계열 데이터나 tidy 데이터 전처리에 유용합니다.

## 1. melt 함수란?

Pandas의 `melt()` 함수는 **열(column)을 행(row)으로 바꾸는 형태의 데이터 구조 변환 함수**입니다. 관측 대상(identifier variables)은 그대로 두고, 여러 열로 나뉜 측정값(measure variables)을 하나의 열로 모아서 정리합니다.

### 기본 사용법

```python
pd.melt(frame, id_vars=None, value_vars=None, var_name=None, value_name='value', ...)
```

- `id_vars`: 그대로 유지할 열 (식별자 역할)
- `value_vars`: 녹일 열 (기본값은 모든 나머지 열)
- `var_name`: 녹인 열의 이름
- `value_name`: 값 열의 이름

이제 실제 코드 예제로 들어가보겠습니다.

---
```python
import pandas as pd

# pew.csv 파일을 읽어서 DataFrame 생성
pew = pd.read_csv('../data/pew.csv')

# 'religion' 열을 제외한 나머지 열들을 변수로 세우고, 값을 value로 세로로 녹임
pew_long = pew.melt(id_vars = 'religion')

# melt 함수에서 변수명과 값 이름을 명시적으로 지정하여 더 읽기 쉽게 만듦
pew_long = pew.melt(
    id_vars = 'religion',      # 기준 열 지정
    var_name = 'income',       # 녹인 열의 이름을 'income'으로 지정
    value_name = 'count'       # 값 열 이름을 'count'로 지정
)

```

| religion             | income | count |
|----------------------|--------|-------|
| Agnostic             | <$10k  | 27    |
| Atheist              | <$10k  | 12    |
| Buddhist             | <$10k  | 27    |
| Catholic             | <$10k  | 418   |
| Don’t know/refused   | <$10k  | 15    |


`pew` 데이터는 여러 종교별 소득 구간 데이터이며, 이를 종교별로 여러 소득 구간이 열로 나누어진 데이터를 세로로 길게 변환(melt)해 'income'과 'count' 열로 정리합니다. 이렇게 하면 분석 및 시각화에 편리합니다.

```python
# billboard.csv 파일을 읽어서 DataFrame 생성
billboard = pd.read_csv('../data/billboard.csv')

# 여러 주(week)별 음악 차트 랭킹 데이터가 열로 되어 있으므로
# 'year', 'artist', 'track', 'time', 'date.entered' 열을 기준으로
# 나머지 주별 열들을 세로로 녹여 'week'와 'rating' 열로 만듦
billboard_long = billboard.melt(
    id_vars = ['year', 'artist', 'track', 'time', 'date.entered'],
    var_name = 'week',        # 녹인 열 이름을 'week'로 지정
    value_name = 'rating'     # 값 열 이름을 'rating'으로 지정
)

```

| year | artist      | track                        | time | date.entered | week | rating |
|------|-------------|------------------------------|------|---------------|------|--------|
| 2000 | 2 Pac       | Baby Don't Cry Keep...      | 4:22 | 2000-02-26    | wk1  | 87.0   |
| 2000 | 2Ge+her     | The Hardest Part Of ...      | 3:15 | 2000-09-02    | wk1  | 91.0   |
| 2000 | 3 Doors Down| Kryptonite                   | 3:53 | 2000-04-08    | wk1  | 81.0   |
| 2000 | 3 Doors Down| Loser                        | 4:24 | 2000-10-21    | wk1  | 76.0   |
| 2000 | 504 Boyz    | Wobble Wobble                | 3:35 | 2000-04-15    | wk1  | 57.0   |

빌보드 데이터는 여러 주 별로 순위가 열에 나누어져 있으므로, 이 데이터를 기준 열을 유지하며 주별 순위를 'week'와 'rating'으로 변환하여 분석하기 쉽게 만듭니다.

```python
# ebola (에볼라 감염자 데이터) 파일을 읽음
ebola = pd.read_csv('../data/country_timeseries.csv')

# 'Date'와 'Day' 열을 기준으로 나머지 변수들(예: infected_Guinea)을 세로로 녹임
ebola_long = ebola.melt(id_vars = ['Date', 'Day'])

# 녹인 변수명을 '_' 기준으로 분리 (예: infected_Guinea → ['infected', 'Guinea'])
variable_split = ebola_long.variable.str.split('_')

# 분리한 첫 번째 값을 'status' (상태, 예: infected), 두 번째 값을 'country' (국가명)으로 지정
status_values = variable_split.str.get(0)
country_values = variable_split.str.get(1)

# ebola_long에 새로운 열 'status', 'country' 추가
ebola_long['status'] = status_values
ebola_long['country'] = country_values

```

| Date       | Day | variable     | value  | status | country |
|------------|-----|--------------|--------|--------|---------|
| 1/5/2015   | 289 | Cases_Guinea | 2776.0 | Cases  | Guinea  |
| 1/4/2015   | 288 | Cases_Guinea | 2775.0 | Cases  | Guinea  |
| 1/3/2015   | 287 | Cases_Guinea | 2769.0 | Cases  | Guinea  |
| 1/2/2015   | 286 | Cases_Guinea | NaN    | Cases  | Guinea  |
| 12/31/2014 | 284 | Cases_Guinea | 2730.0 | Cases  | Guinea  |


에볼라 데이터의 열 이름이 감염 상태와 국가가 언더스코어로 붙어 있으므로, `melt` 후 변수명을 분리해 `감염 상태(status)`와 `국가(country)` 정보를 각각 별도 열로 만듭니다. 이후 데이터를 세로로 길게 변환해 시계열 분석에 용이하게 만듭니다.

```python
# weather.csv 파일을 읽음
weather = pd.read_csv('../data/weather.csv')

# 'id', 'year', 'month', 'element' 열을 기준으로 나머지 일(day)별 데이터 녹임
weather_melt = weather.melt(
    id_vars = ['id', 'year', 'month', 'element'],  # 기준 열 지정
    var_name = 'day',                              # 녹인 열 이름을 'day'로 지정
    value_name = 'temp'                            # 값 열 이름을 'temp'로 지정
)

# element(예: TMAX, TMIN)가 컬럼이 되고, id, year, month, day를 기준으로 하는 피벗 테이블 생성
weather_tidy = weather_melt.pivot_table(
    index = ['id', 'year', 'month', 'day'],
    columns = 'element',
    values = 'temp'
)

# 다중 인덱스를 해제하여 평평한 형태로 만듦
weather_tidy_flat = weather_tidy.reset_index()

# 위 과정을 메소드 체이닝으로 한 줄에 작성한 버전
weather_tidy = (
    weather_melt.pivot_table(
        index = ['id', 'year', 'month', 'day'],
        columns = 'element',
        values = 'temp'
    ).reset_index()
)

```

| element | id      | year | month | day | tmax | tmin |
|---------|---------|------|-------|-----|------|------|
| 0       | MX17004 | 2010 | 1     | d30 | 27.8 | 14.5 |
| 1       | MX17004 | 2010 | 2     | d11 | 29.7 | 13.4 |
| 2       | MX17004 | 2010 | 2     | d2  | 27.3 | 14.4 |
| 3       | MX17004 | 2010 | 2     | d23 | 29.9 | 10.7 |
| 4       | MX17004 | 2010 | 2     | d3  | 24.1 | 14.4 |

날씨 데이터에서 `관측 요소(element)`를 행으로 녹인 후, 다시 피벗해서 요소별 값이 열로 정리되도록 변환합니다. 이렇게 하면 TMAX, TMIN 등의 변수가 별도 열로 구분되어 한 행이 한 날짜/장소에 대한 기록이 됩니다.
